import json
import declxml as xml
import sys

"""
******** Mend Script to Convert CLI SCA Scan JSON Files to JUnit XML Files ********

Users should edit this file to ingest the correct file, and to control the name of the resulting file.
Users can also edit the "SPACE_INDENT" and SPACE_CHAR variables to control the indentation of the resulting file.
Users can also feel free to edit, to add other information to the resulting xml file.

For more information on the Mend CLI and how to generate a file for this script, please check our documentation page:
ðŸ“š https://docs.mend.io/bundle/integrations/page/configure_the_mend_cli_for_sca.html

******** Description ********
This script takes a scan.json generated by the Mend CLI, and translates it to a JUnit XML file.
The execution process looks like:
1. Read the JSON file and ingest it as Python Lists/Dictionaries.
2. Translate all "dependencyFile" and "license" entries to properties for the JUnit file. Also parsing vulnerability information for each dependency.
3. Create a 'declxml' processor for the resulting JUnit XML.
4. Run the processor against the ingested object.
5. Output to XML file.

******** Usage ********
After creating a scan.json file with the Mend CLI, make sure to install the appropriate dependencies before running this script. Afterwards, you can run the script with:
python3 convert_scan_to_junit_xml.py [input-file] [output-file]

Optional Arguments: if input-file and output-file are not specified, then the values used will be "scan.json" and "scan_junit.xml" respectively.

Pre-requisites:
apt-get install python39
pip install declxml
INPUT_FILE
"""

SPACE_INDENT=2
SPACE_CHAR=" "

def flatten_dependencies(search_array: list, children: list=[]) -> None:
    """
    Takes an array of dependencies and gets all child dependencies. Then puts them at the top level.
    """
    if children == []:
        children = search_array
        
    for dependency in children:
        if "children" in dependency:
            flatten_dependencies(search_array, dependency["children"])
            del dependency["children"]
        elif children != search_array:
            search_array.append(dependency)

def translate_properties(json_object):
    """
    Flattens all of the children dependencies to one level and removes children.
    Translates all top level dependency "dependencyFile" and "licenses" to Properties.
    Re-formats the "vulnerability" portions for translation to junit xml.
    """
    
    flatten_dependencies(json_object)
    
    for dependency in json_object:
        dependency["properties"] = []
        if "dependencyFile" in dependency:
            dependency["properties"].append({"name": "dependencyFile", "value": dependency["dependencyFile"]})
            del dependency["dependencyFile"]
        
        if "licenses" in dependency:
            dependency["properties"].append({"name": "licenses", "value": ", ".join(dependency["licenses"])})
            del dependency["licenses"]
            
        if dependency["properties"] == []:
            del dependency["properties"]
            
        if "vulnerabilities" in dependency:
            for vulnerability in dependency["vulnerabilities"]:
                vulnerability["message"] = f"Vulnerability: {vulnerability['name']}: - Severity: {vulnerability['severity']}"
                vulnerability["output"] = f"Vulnerability Found: {vulnerability['name']}\nVulnerability Severity: {vulnerability['severity']}\nCVSS 3.0 Score: {vulnerability['score']}\nVulnerability Fix: {vulnerability['topFix']['fixResolution']}\nLearn More: {vulnerability['topFix']['url']}"
                vulnerability['type'] = "Vulnerability"
                del vulnerability["name"]
                del vulnerability["severity"]
                del vulnerability["score"]
                del vulnerability["cvss3_severity"]
                del vulnerability["cvss3_score"]
                del vulnerability["scoreMetadataVector"]
                del vulnerability["publishDate"]
                del vulnerability["url"]
                del vulnerability["description"]
                del vulnerability["topFix"]
                del vulnerability["allFixes"]
                
            

def create_processor() -> xml.RootProcessor:
    """
    Creates a declxml processor that takes all dependencies and translates them to xml.
    """
    print("Creating document processor")
    scan_processor = xml.dictionary('testsuites', [
        xml.string('.', attribute='name', required=False, default="Test Suite"),
        xml.dictionary("testsuite", [
            xml.string('.', attribute='name', required=False, default="Test Suite"),
            xml.array(xml.dictionary('testcase', [
                xml.string('.', attribute='name'),
                xml.array(xml.dictionary('property', [
                    xml.string('.', attribute="name"),
                    xml.string('.', attribute="value")
                ], required=False), nested="properties"),
                xml.array(xml.dictionary('failure', [
                    xml.string('.', alias="output"),
                    xml.string('.', attribute="message"),
                    xml.string('.', attribute="type")
                ], required=False), alias="vulnerabilities")
            ]))
        ])
    ])
    
    return scan_processor


def main():
    # Set INPUT_FILE and OUTPUT_FILE if specified.
    if len(sys.argv) >= 2:
        INPUT_FILE=sys.argv[1]
    else:
        INPUT_FILE="scan.json"
    
    if len(sys.argv) == 3:
        OUTPUT_FILE=sys.argv[2]
    else:
        OUTPUT_FILE="scan_junit.xml"
    
    # Read file and output to object
    print(f"Getting file contents for: {INPUT_FILE}")
    with open(INPUT_FILE, "r") as file:
        json_file_as_object = json.loads(file.read())
        
    # Translate object and create processor
    translate_properties(json_file_as_object) 
    scan_processor = create_processor()
        
    # Format and add "testsuites/testsuite/testcase" into the object so it gets printed out properly.
    testsuites = {
        'testsuite': {
            'testcase': json_file_as_object
        }
    }
    
    #Output to XMLFile
    print(f"Processing {INPUT_FILE}...")
    indent = SPACE_CHAR * SPACE_INDENT
    output = xml.serialize_to_string(scan_processor, testsuites, indent=indent)
    with open(OUTPUT_FILE, "w") as xmlfile_writer:
        xmlfile_writer.write(output)        
        
    print("Finished")
    #What results is an xml file in the JUnit XML format.
    

if __name__ == "__main__":
    main()