import json
import declxml as xml

"""
******** Mend Script to Convert CLI SCA Scan JSON Files to JUnit XML Files ********

Users should edit this file to ingest the correct file, and to control the name of the resulting file.
Users can also edit the "SPACE_INDENT" and SPACE_CHAR variables to control the indentation of the resulting file.
Users can also feel free to edit, to add vulnerability information, sha1's and more.

For more information on the Mend CLI and how to generate a file for this script, please check our documentation page:
ðŸ“š https://docs.mend.io/bundle/integrations/page/configure_the_mend_cli_for_sca.html

******** Description ********
This script takes a scan.json generated by the Mend CLI, and translates it to a JUnit XML file.
The execution process looks like:
1. Read the JSON file and ingest it as Python Lists/Dictionaries.
2. Translate all "dependencyFile" and "license" entries to properties for the JUnit file.
3. Create a 'declxml' processor by nesting children processors, and then adding the relevant top-level information.
4. Run the processor against the ingested object.
5. Output to XML file.

Pre-requisites:
pip install declxml
INPUT_FILE
"""

INPUT_FILE="scan.json"
OUTPUT_FILE="scan_junit.xml"
SPACE_INDENT=2
SPACE_CHAR=" "

def translate_recursively(search_dict, field) -> int:
    """
    Finds all of the nested children and translates dependencyFile and license
    to properties. Also get's the max recursion depth so we know how much to include
    in the junit processor
    """
    
    current_depth = 0
    for key, value in search_dict.items():
        if key == field:
            for dependency in search_dict[key]:
                current_depth = max(current_depth, translate_recursively(dependency, "children"))
                dependency["properties"] = [
                    {"name": "dependencyFile", "value": dependency["dependencyFile"]},
                    {"name": "license", "value": ", ".join(dependency["licenses"])}
                ]
                del dependency["dependencyFile"]
                del dependency["licenses"]

        elif isinstance(value, dict):
            translate_recursively(value, field)

        elif isinstance(value, list) and key != "vulnerabilities":
            for item in value:
                if isinstance(item, dict):
                    translate_recursively(item, field)
    
    return 1 + current_depth


def translate_properties(json_object) -> int:
    """
    Translates all top level dependency "dependencyFile" and "licenses" to Properties.
    Then do the same thing recursively.
    Return the max recursion depth returned from "translate_recursively."
    """
    
    max_depth = 0
    for dependency in json_object:
        max_depth = max(translate_recursively(dependency, "children"), max_depth)
        dependency["properties"] = [
            {"name": "dependencyFile", "value": dependency["dependencyFile"]},
            {"name": "license", "value": ", ".join(dependency["licenses"])}
        ]
        del dependency["dependencyFile"]
        del dependency["licenses"]
    return max_depth - 1


def main():
    # Read file and output to object
    print(f"Getting file contents for: {INPUT_FILE}")
    with open(INPUT_FILE, "r") as file:
        json_file_as_object = json.loads(file.read())
        
    # Translate object and get max recursion depth for processing
    max_depth = translate_properties(json_file_as_object) 
        
    # Format and add "testsuites/testsuite/testcase" into the object so it gets printed out properly.
    testsuites = {
        'testsuite': {
            'testcase': json_file_as_object
        }
    }
    
    # Create our base "child processor". 
    # Our next for loop does the same thing, but will nest it until max_depth is reached.
    print("Creating document processor")
    child_processor = xml.dictionary('testcase', [
        xml.string('.', attribute='name'),
        xml.array(xml.dictionary('property', [
            xml.string('.', attribute="name"),
            xml.string('.', attribute="value")
        ]), nested="properties"),
        xml.string('system-out', required=False),
        xml.string('system-err', required=False)
    ], required=False, alias="children")
    
    for _ in range(max_depth):
        child_processor = xml.dictionary('testcase', [
            xml.string('.', attribute='name'),
            xml.array(xml.dictionary('property', [
                xml.string('.', attribute="name"),
                xml.string('.', attribute="value")
            ]), nested="properties"),
            xml.string('system-out', required=False),
            xml.string('system-err', required=False),
            xml.array(child_processor)
        ], required=False, alias="children")
    
    #Finish off our processor with the data we need at the top level.
    scan_processor = xml.dictionary('testsuites', [
        xml.string('.', attribute='name', required=False, default="Test Suite"),
        xml.dictionary("testsuite", [
            xml.string('.', attribute='name', required=False, default="Test Suite"),
            xml.array(xml.dictionary('testcase', [
                xml.string('.', attribute='name'),
                xml.array(xml.dictionary('property', [
                    xml.string('.', attribute="name"),
                    xml.string('.', attribute="value")
                ]), nested="properties"),
                xml.string('system-out', required=False),
                xml.string('system-err', required=False),
                xml.array(child_processor)
            ]))
        ])
    ])
    
    #Output to XMLFile
    print(f"Processing {INPUT_FILE}...")
    indent = SPACE_CHAR * SPACE_INDENT
    output = xml.serialize_to_string(scan_processor, testsuites, indent=indent)
    with open(OUTPUT_FILE, "w") as xmlfile_writer:
        xmlfile_writer.write(output)        
        
    print("Finished")
    #What results is an xml file in the JUnit XML format.
    

if __name__ == "__main__":
    main()